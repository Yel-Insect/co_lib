##C++网络服务框架-协程库
## 日志模块

用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。通过 `LOG_NAME` 或者 `LOG_ROOT` 宏定义来生成一个日志器，再由`LOG_LEVEL`进行输出，支持多种日志等级、日志格式以及输出流。

示例：

```c++
co_lib::Logger::ptr logger = LOG_NAME("name");
LOG_INFO << "我是日志";
```



## 配置模块

定义即可使用，支持更变时提醒。使用YAML文件作为配置内容，支持内置数据类型以及常用容器类型，自定义数据则需要自行实现序列化与反序列化。

示例：

```c++
// 从配置文件中获取Person的ID
co_lib::ConfigVar<int>::ptr person_id = 
	 co_lib::Config::Lookup("person.id", 1, "Person' s ID")
```

配置文件如下：

```yaml
person:
    id: 12
```



## 线程模块

封装了pthread、信号量以及Linux中常用的锁，不支持给线程函数传入参数(因为需要传递线程本身的对象)，如果需要传递参数，则需要使用`std::bind`来绑定参数。



## 协程模块

基于ucontext实现的非对称协程，后续搭配Hook封装，可将复杂的异步调用封装为同步调用。



## 协程调度模块

协程调度器，管理协程的调度，内部实现为一个线程池，支持协程在多线程中切换，也可以指定协程在固定的线程中执行。是一个N-M的协程调度模型，N个线程，M个协程。重复利用每一个线程。



## IO协程调度模块

继承于协程调度器，封装了epoll，并支持定时器功能，支持Socket读写时间的添加、删除、取消功能。支持一次性定时器，循环定时器，条件定时器等功能



## Hook模块

利用hook+IO协程调度器+定时器技术，重新实现了原有的网络IO接口，使其以同步方式实现异步的性能



## 待实现的优化方案

- 了解到ucontext虽然安全可靠，但性能比较差，切换性能大概只有200万次/秒左右，而boost.context性能与兼容性目前最佳，切换性能大概在1.25亿次/秒左右，因此可以采用更高效的boost.context来实现协程
- 对调度器的任务队列采用一个多队列共享机制：
  - 为每个线程分配一条任务队列，当由任务时线程仅从自己的队列中消费任务，减少队列锁竞争
  - 如果队列中没有任务，即寻找别的队列中是否有任务需要被消费，避免任务积压
- 分离式协程类复用池：维护两条队列，一条共享的队列，一条线程私有队列，当需要用到协程对象时则优先从私有队列中取出，如果没有则从共享队列中取出；当销毁协程时，则从将其放入私有队列当中。
- 实现共享栈
